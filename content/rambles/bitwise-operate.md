Title: 关于位运算的一些事
Date: 2016-02-08 23:40
Tags: meaningless
Category: 漫谈

今天是大年初一，白天去女朋友家里拜了个年，晚上回来看到几位大(tong)哥(shi)在微信群讨论工作...这是成心不让人过好年啊T^T！所以硬着头皮掏出书来看了一会...

然而很快就被一个系列的题给击倒了...虽然感觉一年的第一天就对困难低头不太好啊><

**但是思索未果（手动滑稽）**

最后还是看解答了。是的，就是位运算的解法，这么一想位运算好像真的都还给老师了呢

是这样的三个渐进式问题：

1. **在一个数组中，有一个数只出现一次，其他的数都出现了两次**
2. **在一个数组中，有两个数只出现一次，其他的数都出现了两次**
3. **在一个数组中，有三个数只出现一次，其他的数都出现了两次**

问你这些数都是啥，都是啥呀！时间和空间复杂度那必须是O(n)和O(1)了...

唉，借此机会，稍微补了一下位运算的知识，总结如下：

# 位运算小知识

```python
x ^ x = 0                   # 一个数和自身按位异或，结果为0
-x = ~x + 1                 # 反码+1等于补码
x = x >> 1                  # 去掉最后一位
x = x << 1                  # 在最后一位加个0
x = x << 1 + 1              # 在最后一位加个1
x = (x << k) & 1            # 取右数第k位
x = x | (1 << (k - 1))      # 把右数第k位变成1
x = x & ~(1 << (k - 1))     # 把右数第k位变成0
x = x ^ (1 << (k - 1))      # 对右数第k位取反
x = x & ((1 << k) - 1)      # 取后k位
x = x | ((1 << k) - 1)      # 将后k位变成1
x = x >> k << k             # 将后k位变成0
x = x ^ ((1 << k) - 1)      # 对后k位取反
x = x & (x + 1)             # 把右边连续的1变成0
x = x | (x - 1)             # 把右边连续的0变成1
x = x & (x - 1)             # 把右起第一个1变成0
x = x | (x + 1)             # 把右起第一个0变成1
x = (x ^ (x + 1)) >> 1      # 找到右起连续的1
x = x & (x ^ (x - 1))       # 找到右起第一个1
x = x & (-x)                # 同样用于找到右起第一个1
```

补充了基本知识，感觉这几道题也就迎(ke)刃(yi)而(jie)解(jue)了

# 一个只出现一次的数字

很简单，由于一个数和自身按位异或结果为0，只要对数组中的每一个数都做按位异或操作，最后剩下来的数就是了

```python
return reduce(lambda x, y: x ^ y, nums)
```

# 两个只出现一次的数字

这个要稍微复杂一点，我们假设这两个数为a, b, 上文reduce的结果为x，那么很显然

```
x = a ^ b
```

由于a和b互不相同，也就是说a ^ b > 0，亦即x总有一位为1，**由于按位异或的特性、这一位也是a和b不同的位**。

很容易想到将原数组根据这一位分成两组，对每一组再进行按位异或操作得到a和b

```python
x = reduce(lambda x, y: x ^ y, nums)

# 找到右起第一个1，也就是a和b不同的那一位
t = x & (-x)

# 根据这一位将数组分成两部分，分别求唯一的数
a, b = 0, 0
for num in nums:
    if num & t:
        a = a ^ num
    else:
        b = b ^ num
return a, b
```

# 三个只出现一个的数字

这个相对来讲就复杂的多了，首先我们可以知道：

```python
x = a ^ b ^ c

# 位运算满足交换律
xa = x ^ a = b ^ c
xb = x ^ b = a ^ c
xc = x ^ c = a ^ b

# 令f(x) = x & (-x)，（其实就是取x最右边的1）
f = lambda x: x & (-x)

y = f(xa) ^ f(xb) ^ f(xc)
```

由于f(x)的结果只会有一个1出现，因此f(xa) ^ f(xb)只可能有2个或0个1，也就是说y的结果至少有一个1

假设y最右边的1在第n位

根据按位异或的定义可知，f(xa), f(xb), f(xc)至少有一个的第n位是1

再根据f的定义，也就是说xa、xb、xc中，至少有一个的第n位是1

**下面利用反证法证明，xa、xb、xc中，有且仅有一个的第n位是1**

1. 假设xa和xb的第n位是1，xc的第n位是0。那么f(xa) ^ f(xb)结果的第n位为0，又xc的第n位是0，得知f(xa) ^ f(xb) ^ f(xc)的第n位为0，矛盾。

2. 假设xa，xb，xc的第n位都是1，说明a、b、c的第n位两两不同，根据抽屉原理，矛盾。

**因此，对于xa、xb、xc，有且仅有一个的第n位为1，其中n是f(xa) ^ f(xb) ^ f(xc)最右边的1的位数**

有了这个结论，我们找到其中一个仅出现过一次的数就容易了

```python
xor = lambda x, y: x ^ y
f = lambda x: x & (-x)

x = reduce(xor, nums)

# 对于相同的a和b，f(x ^ a) ^ f(x ^ b) = f(x ^ a) ^ f(x ^ a) = 0
# 因此y = f(x ^ a) ^ f(x ^ b) ^ f(x ^ c)，因为其他两两相同的数在运算中已经消除了
y = reduce(xor, [f(x ^ num) for num in nums])
# 取出y的最右边的1
y = f(y)

a = 0
for num in nums:
    if num & y:
        a = a ^ num
```

找到了a，那么只要抛去a，剩下的就是上一节中解决的子问题了

```python
# 即t = f(b ^ c)
t = f(x ^ a)
b, c = 0, 0
for num in nums:
    if num == a:
        continue
    elif num & t:
        b = b ^ num
    else:
        c = c ^ num
```

不得不说这个思路真是有点...**brilliant and tricky**...看来消化这一算法还需要一定的时间
