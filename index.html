<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://stdrickforce.github.io/Index/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/Index/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Index/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/Index/">Home</a>
        
          <a class="main-nav-link" href="/Index/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://stdrickforce.github.io/Index"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-My-New-Post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Index/2017/09/15/My-New-Post/" class="article-date">
  <time datetime="2017-09-15T10:24:48.000Z" itemprop="datePublished">2017-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Index/2017/09/15/My-New-Post/">My New Post</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://stdrickforce.github.io/Index/2017/09/15/My-New-Post/" data-id="cj7q31mbp000062vdvjatqa9m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Thrift TPC 在百姓网的实践之路（第一版）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Index/2017/09/15/Thrift TPC 在百姓网的实践之路（第一版）/" class="article-date">
  <time datetime="2017-09-15T10:16:11.000Z" itemprop="datePublished">2017-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>「服务化」是一个互联网公司从小到大过程中不可缺少的一段旅程。百姓网作为一个具有十年历史的“老”公司，沉重的历史包袱导致我们主站的设计上仍然是单体应用。但随着业务的扩张、后端技术团队的逐步分化、跨系统之间的调用越来越多，原本的系统架构已经不堪重负。缺乏统一标准的远程调用导致出现问题很难排查，而内部文档的缺乏更是造成极大的代码冗余。一个高效易用的「服务化」框架已经迫在眉睫。</p>
<h3 id="谈谈问题所在"><a href="#谈谈问题所在" class="headerlink" title="谈谈问题所在"></a>谈谈问题所在</h3><p>「服务化」涉及到的概念非常广，也有很多的文章专门去阐述这个词的定义。但抛开各自的理解和实现不谈，对我来讲，服务化解决的主要是以下几个问题：</p>
<ul>
<li>跨语言调用</li>
<li>同一功能被多次实现，产生冗余代码</li>
<li>底层复杂度过高，业务耦合严重</li>
<li>各模块无法独立部署，相互影响</li>
</ul>
<p>但一项新技术的引入，势必会带来一些新的问题：</p>
<ul>
<li>服务化后的 API 分散在各个系统中，不易查找</li>
<li>调用链路上的某个环节出错后，很难追溯</li>
<li>影响工程师的开发习惯，降低开发效率</li>
<li>性能下降，消耗更多的系统资源</li>
</ul>
<h2 id="实践之路"><a href="#实践之路" class="headerlink" title="实践之路"></a>实践之路</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>当我们决定开始「服务化」的时候，技术选型是非常重要的，但在此之前，我们希望能够让我们的主站平滑的过渡到RPC调用，先看看我们原本的架构图：</p>
<p>（架构图）</p>
<p>Controller（即传统 MVC 模式中的展示层）直接进行本地或远程调用，稍微好一些的代码可能会做一层封装，但并不通用。稍有常识的人都能看出，如果我们就这样推行服务化，将涉及到大量的代码改动。因此，我们对架构做了一些小的修改并预先推行。</p>
<p>（架构图2）</p>
<blockquote>
<p>中间层定律：任何计算机问题都可以通过中间加一层来解决</p>
</blockquote>
<p>我们预先将系统内部划分为不同的 Module，同时在 Controller 和 Module，Module 和 Module 的调用之间加上一层 Proxy，从而对调用方屏蔽了底层细节，也为我们将来整体替换某个 Module 为 RPC 调用时提供了便利。</p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>由于百姓网的技术栈比较多样（PHP／Python／Java／Node.js），<strong>跨语言调用</strong>也变成了我们最核心的需求，而<strong>序列化协议</strong>则是核心中的核心。基本类型还好说，对于复杂一点的结构，就需要一个统一的标准，以使数据能够在不同语言间传输。很快我们的眼光就落在 <strong>Thrift</strong> 和 <strong>Protobuf</strong> 上。</p>
<p>功能上来看，两者的功能差别不是很大，值得注意的有如下几点：</p>
<ul>
<li>Protobuf 更优雅的诠释了流式传输，数组和普通字段可以相互转换（通过 repeated 关键字），这为日后可能的字段变更留下了余地</li>
<li>Thrift 原生支持 exception，这也使得 Thrift 可以直接返回基本数据类型（而不像 Protobuf 必须封装成一个 Message 对象）</li>
<li>Thrift 在语言设计上支持参数默认值</li>
</ul>
<p>性能角度上看，Protobuf 在序列化和反序列化上消耗的时间较少（Thrift 达到同等的压缩比需要更多的计算资源）。</p>
<blockquote>
<p>Protobuf 的文档比较齐全，相比之下，Thrift 显得没有什么文档</p>
</blockquote>
<p>而最终使我们决定使用 Thrift 的原因则是其优雅的三层结构设计。从架构开发的角度来讲，这一设计为我们逐层做替换和优化留下了很多余地。</p>
<blockquote>
<p>Protobuf 是由 Google 主导的项目，而相比之下 Thrift 是由 Facebook 设计并开发，其对 PHP 的支持要好的很多，也减少了我们一定的开发工作。</p>
</blockquote>
<h3 id="文档中心"><a href="#文档中心" class="headerlink" title="文档中心"></a>文档中心</h3><p>我们之前提到服务化带来的问题之一就是<strong>API分散不易查找</strong>，一个统一API文档中心就显得非常必要了。在我看来，一个文档中心项目需要实现以下目标：</p>
<ul>
<li>自动化</li>
<li>API版本控制</li>
<li>支持代码注释</li>
</ul>
<p>很容易想到的是借助CI工具来实现上述目标。由于我们的项目都是托管在GitHub／自建GitLab里的，当接口发生变动时，我们可以通过 webhook 来得知改动的发生，并通过 api 来获取改动的内容，从而生成新版本的文档。</p>
<p>而历史版本的文档，依托 GitLab 的版本控制功能也能很好的实现，我们在项目中单开了一个 branch 来归档历史版本。</p>
<p>代码注释是相对比较烦的一个部分，由于我们文档中心的项目是使用 Python 进行开发的，不能利用 PHP 内置的反射机制来获取 API 的注释。最终我们选择使用 ply（Python Lex-Yacc）来对 PHP 代码进行语法分析，补全文档中需要从注释中获取的信息。</p>
<p>至于文档生成的部分我们使用了 Sphinx，其可以通过中间文件（.rst）生成 HTML 或 PDF 格式的文档。</p>
<blockquote>
<p>Python 的开发者工具相当完善，开发内部系统时，应首选 Python</p>
</blockquote>
<p>最终我们整个自动化流程是这样的：</p>
<p>（图）</p>
<h3 id="请求追踪"><a href="#请求追踪" class="headerlink" title="请求追踪"></a>请求追踪</h3><p>服务之间的相互调用会使调用链变得复杂，试想如下一个场景：</p>
<blockquote>
<p>A -&gt; B -&gt; C -&gt; B</p>
</blockquote>
<p>正常情况下岁月静好，一旦某个环节出现了问题：</p>
<blockquote>
<p>A -&gt; B -&gt; C (raise exception)</p>
</blockquote>
<p>这时尴尬的一幕就出现了，A 和 B 服务不知道错误的具体内容，但 C 服务虽然知道错误的发生原因，但它并不知道是谁调用了它，这就极大的提高了我们查找问题的难度。为了解决这一问题，我们引入了reqid（request id），对于一次请求的调用链上的每一部分，都共享唯一一个reqid，从而使我们可以知道一次 exception 到底穿过了哪些服务。</p>
<p>问题就在于这个 reqid 如何在服务中传递。Thrift 协议本身没有存放 meta 信息的位置，因此要实现 meta，就需要我们自己做出一些修改。我们先看一下 Thrift 协议的 request 结构：</p>
<p>（图）</p>
<p>由于 Thrift 是流式解析的，很容易想到的是在 method_name 上面做一些魔改。</p>
<p>（图）</p>
<p>客户端发起请求时，将原本放置 method_name 的位置替换为 <code>__track_method</code>，并在后面接上包含真实 method_name 和 meta 信息的<code>TRequestHeader</code>。而服务端接受请求时，先判断 method_name，如果是<code>__track_method</code>的话，就先读取<code>TRequestHeader</code>再读取 body，反之则直接读取 body，从而实现兼容原协议的改动。</p>
<blockquote>
<p>服务端返回时也会加上<code>TResponseHeader</code>，原理同上</p>
</blockquote>
<p>对于客户端不确定服务端是否支持 Tracking 的情况，可以发起一次 RPC 请求，在返回的内容中获取服务端状态。</p>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>Thrift 在使用时需要预先编译 Thrift 文件，生成相应的 Helper class。这对于开发者来说是很痛苦的（试想每一次修改接口都需要执行命令重新编译构建）。但对于动态语言来讲，完全可以在运行时生成对应的 Helper class，从而避免每次改动后的编译构建过程。</p>
<p>最开始我们想做成一个可直接通过 composer 安装的 PHP 模组，并基于 php-lime 做了一个简单的 demo。不幸的是，解析一个1000行左右的 Thrift 文件花了100ms。鉴于我们目前服务模型仍是基于 php-fpm（正在迁往 swoole），每个请求都要重新构建语法树，这一方案很快被搁置了。</p>
<p>后来我们把目光转向了 C 扩展，但比较尴尬的一点是百姓网当时正处于 PHP5 升级 PHP7 的过渡阶段。关注 PHP 的同学可能知道 PHP5 和 PHP7 从底层的数据结构开始就发生了很大的变动，同时维护两个版本的扩展开发是非常花费时间的。</p>
<p>但这问题也得到了解决，后来我们发现了 PHP-CPP，这是一个可以基于 C++ 开发 PHP 扩展的工具。它为我们屏蔽了 C 底层的细节，并提供 PHP5 和 PHP7 两个版本的支持。</p>
<blockquote>
<p>中间层定律：任何计算机问题都可以通过中间加一层来解决</p>
</blockquote>
<p>在 C 环境中做构建语法树的工作就比较简单了，同时 apache/thrift 提供了 compiler 和 php code generator 部分，我们基于这个做了一些改动，从而实现了<strong>运行时构建 Thrift RPC 所需的文件</strong>，最终解析一个1000行的 Thrift 文件耗费的时间大约是12ms。</p>
<blockquote>
<p>PHP-CPP 的使用过程中有一个小插曲，由于我们仍然在使用 centos6，gcc 的版本哪怕是使用了 devtoolset 的 4.8.2 版本，仍然存在一个影响 extern 关键字的 bug，强烈建议在编译安装 PHP-CPP 的时候使用 4.9.0+ 的 gcc。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://stdrickforce.github.io/Index/2017/09/15/Thrift TPC 在百姓网的实践之路（第一版）/" data-id="cj7q31mby000162vdf8yukjbh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Index/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Index/2017/09/15/My-New-Post/">My New Post</a>
          </li>
        
          <li>
            <a href="/Index/2017/09/15/Thrift TPC 在百姓网的实践之路（第一版）/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/Index/" class="mobile-nav-link">Home</a>
  
    <a href="/Index/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/Index/fancybox/jquery.fancybox.css">
  <script src="/Index/fancybox/jquery.fancybox.pack.js"></script>


<script src="/Index/js/script.js"></script>

  </div>
</body>
</html>